# Chapter12. 함수

<br>

## 1. 함수란?

### (1) 함수 구성

```javascript
// f(x, y) = x + y
function add(x, y) {
  return x + y;
}

// f(2, 5) = 7
add(2, 5); // 7
```

- 프로그래밍 언어의 함수는 일련의 과정을 문(statement)으로 구현하고 코드 블록으로 감싸서 하나의 실행 단위로 정의한 것이다.

- 함수를 구성하는 요소

  ![function](https://user-images.githubusercontent.com/52685250/154847515-c5720bed-c3e5-40dd-bac8-0b4165e57e95.JPG)

  - 함수 내부로 입력을 전달받는 변수를 <b>매개 변수(parameter)</b>, 입력을 <b>인수(argument)</b>, 출력을 <b>반환값(return value)</b>이라 한다.
  - 또한 함수는 값이며, 여러 개 존재할 수 있으므로 특정 함수를 구별하기 위한 식별자인 <b>함수 이름</b>을 사용할 수 있다.
  - 위 코드에서 `x`, `y`는 매개 변수, `2`, `5`는 인수, `x + y`는 반환 값, `add`는 함수 이름에 해당한다.

<br>

### (2) 함수의 정의 및 호출

```javascript
// 함수 정의
function add(x, y) {
  return x + y;
}

// 함수 호출
const result = add(2, 5);
console.log(result); // 7
```

<br>

## 2. 함수를 사용하는 이유

- 코드의 재사용
- 유지보수의 편의성
- 코드의 신뢰성
- 코드의 가독성 향상

<br>

## 3. 함수 리터럴

- 자바스크립트의 함수는 객체 타입의 값이다.
- 숫자, 객체와 같이 함수도 함수 리터럴로 생성할 수 있다.

```javascript
// 변수에 함수 리터럴을 할당
const f = function add(x, y) {
  return x + y;
}
```

- 함수 리터럴의 구성 요소

| 구성 요소     | 설명                                                         |
| ------------- | ------------------------------------------------------------ |
| 함수 이름     | <ul><li>함수 이름은 식별자다. 따라서 식별자 네이밍 규칙을 준수해야 한다.</li><li>함수 이름은 함수 몸체 내에서만 참조할 수 있는 식별자다.</li><li>함수 이름은 생략할 수 있다. 이름이 있는 함수를 기명 함수, 이름이 없는 함수를 익명 함수라 한다.</li></ul> |
| 매개변수 목록 | <ul><li>0개 이상의 매개변수를 소괄호로 감싸고 쉼표로 구분한다.</li><li>각 매개변수에는 함수를 호출할 때 지정한 인수가 순서대로 할당된다. 즉, 매개변수 목록은 순서에 의미가 있다.</li><li>매개변수는 함수 몸체 내에서 변수와 동일하게 취급된다. 따라서 매개변수도 식별자 네이밍 규칙을 준수해야 한다.</li></ul> |
| 함수 몸체     | <ul><li>함수가 호출되었을 때 일괄적으로 실행될 문들을 하나의 실행 단위로 정의한 코드 블록이다.</li><li>함수 몸체는 함수 호출에 의해 실행된다.</li></ul> |

- 리터럴은 이전에 살펴보았듯이 사람이 이해할 수 있는 문자 또는 약속된 기호를 사용해 값을 생성하는 표기 방식을 말한다.
  - 즉, 리터럴은 값을 생성하기 위한 표기법이다.
  - 따라서 함수 리터럴도 평가되어 값을 생성하며, 이 값은 객체다.
  - 즉, <b>함수는 객체다.</b>
- 하지만 함수는 일반 객체와는 다르다.
  - 일반 객체는 호출할 수 없지만 함수는 호출할 수 있다.
  - 그리고 일반 객체에는 없는 함수 객체만의 고유한 프로퍼티(`arguments`, `caller`, `length`, `name`)를 갖는다.

<br>

## 4. 함수 정의

### (1) 함수 선언문 (function declaration)

```javascript
// 함수 정의(함수 선언문)
function add(x, y) {
  return x + y;
}

// 함수 호출
console.log(add(2, 5)); // 7
```

- 함수 선언문은 함수 리터럴과 형태가 동일하지만 함수 리터럴과 달리 함수 선언문은 <b>함수 이름을 생략할 수 없다.</b>
- 함수 선언문은 <b>표현식이 아닌 문</b>으로 함수 선언문을 실행하면 완료 값이 `undefined`로 출력된다.
- 하지만 여기서 의문이 드는 포인트가 있을 것이다.
  - 예전에 살펴보았듯이 표현식이 아닌 문은 변수에 할당할 수 없다고 했지만 아래 예제를 실행해보면 함수 선언문이 변수에 할당되는 것처럼 보일 것이다.

```javascript
const add = function add(x, y) {
  return x + y;
};

console.log(add(2, 5)); // 7
```

- 위와 같이 동작하는 이유는 자바스크립트 엔진이 코드의 문맥에 따라 동일한 함수 리터럴을 <b>표현식이 아닌 문인 함수 선언문으로 해석하는 경우</b>와 <b>표현식인 문인 함수 리터럴 표현식으로 해석하는 경우</b>가 있기 때문이다.
  - 함수 이름이 있는 기명 함수 리터럴은 <b>함수 선언문 또는 함수 리터럴 표현식으로 해석될 가능성이 있다.</b>
- 코드의 문맥에 따라 기명 함수 리터럴이 다르게 해석이 될 수 있다.
  - 함수 이름이 있는 함수 리터럴을 단독으로 사용(값으로 평가되어야 할 문맥에서 함수 리터럴을 사용하지 않는 경우)하면 함수 선언문으로 해석하고, 함수 리터럴이 값으로 평가되어야 하는 문맥(함수 리터럴을 변수에 할당하거나 피연산자로 사용하는 경우)에서는 리터럴 표현식으로 해석한다.
  - 두 경우 함수가 생성되는 것은 동일하지만 함수를 생성하는 내부 동작에 차이가 있다.

```javascript
// 기명 함수 리터럴을 단독으로 사용하면 함수 선언문으로 해석
function foo() {
  console.log('foo');
}

foo(); // 'foo'

// 함수 리터럴을 피연산자로 사용하면 함수 리터럴 표현식으로 해석
(function bar() {
  console.log('bar');
});
bar(); // ReferenceError: bar is not defined
```

- `foo` 함수는 함수 선언문으로 해석되지만 그룹 연산자 내에 있는 함수 리터럴 `bar`는 함수 리터럴 표현식으로 해석된다.
  - 그룹 연산자의 피연산자는 값으로 평가될 수 있는 표현식이어야 한다.
  - 따라서 표현식이 아닌 문인 함수 선언문은 피연산자로 사용할 수 없다.
  - 함수 객체를 생성한다는 점에서 동일하지만 함수 선언문으로 생성된 `foo`는 호출할 수 있으나 함수 리터럴 표현식으로 생성된 `bar`는 호출할 수 없다.

![function01](https://user-images.githubusercontent.com/52685250/154842950-ea109688-db71-4088-a77a-e6b134acec33.JPG)

- 함수 `bar` 구문

  - 함수 리터럴에서 '함수 이름은 함수 몸채 내에서만 참조할 수 있는 식별자다'라고 했다.
    - 함수 몸체 외부에서는 함수 이름으로 함수를 참조할 수 없으므로 함수 몸체 외부에서는 함수 이름으로 함수를 호출할 수 없다는 의미다.
    - 즉, 함수를 가리키는 식별자가 없다는 것과 마찬가지다.

- 함수 `foo` 구문

  - 식별자 `foo`를 선언한 적도 없고 할당한 적도 없지만 `foo`는 자바스크립트 엔진이 암묵적으로 생성한 식별자다.
  - 자바스크립트 엔진은 함수 선언문을 해석해 함수 객체를 생성한다.
    - 이때 함수 이름은 함수 몸체 내부에서만 유효한 식별자이므로 함수 이름과는 별도로 생성된 함수 객체가 가리키는 식별자가 필요하다.
  - 그래서 <b>자바스크립트 엔진은 생성된 함수를 호출하기 위해 <u>함수 이름과 동일한 이름의 식별자를 암묵적으로 생성하고, 거기에 함수 객체를 할당</u>한다.</b>

- <b>함수는 함수 이름으로 호출하는 것이 아니라 <u>함수 객체를 가리키는 식별자로 호출</u>한다.</b>

  - 함수 이름과 변수 이름이 일치하므로 함수 이름으로 호출되는 듯하지만 사실은 식별자로 호출된 것이다.

- 함수 선언문의 의사 코드

  ![function02](https://user-images.githubusercontent.com/52685250/154843607-a16c9cae-71d9-4e43-a94b-394285747a9d.JPG)

  - 위 의사 코드가 바로 다음에 살펴볼 함수 표현식이다.
  - 결론적으로 자바스크립트 엔진은 함수 선언문을 함수 표현식으로 변환해 함수 객체를 생성한다고 생각할 수 있다.

<br>

### (2) 함수 표현식 (function expression)

- 자바스크립트의 함수는 일급 객체다.
  - 자바스크립트의 함수는 값처럼 변수에 할당할 수도 있고 프로퍼티의 값이 될 수도 있으며 배열의 요소가 될 수도 있다.
  - 이처럼 값의 성질을 갖는 객체를 일급 객체라 한다.

```javascript
var add = function (x, y) {
  return x + y;
};

console.log(add(2, 5)); // 7
```

- 함수는 일급 객체이므로 함수 리터럴로 생성한 함수 객체를 변수에 할당할 수 있다.
  - 이러한 함수 정의 방식을 함수 표현식이라 한다.
- 함수 표현식의 함수 리터럴은 함수 이름을 생략하는 것이 일반적이다.
- 함수 선언문에서 살펴본 바와 같이 <b>함수를 호출할 때</b>는 함수 이름이 아니라 <b>함수 객체를 가리키는 식별자를 사용</b>해야 한다.

```javascript
var add = function foo(x, y) {
  return x + y;
}

console.log(add(2, 5)); // 7

console.log(foo(2, 5)); // Uncaught ReferenceError: foo is not defined
```

<br>

### (3) 함수 생성 시점과 함수 호이스팅

#### :pushpin: 함수 선언문 호이스팅

- 함수 선언식과 함수 표현식의 가장 큰 차이점은 호이스팅에 있다.
  - 함수 선언식은 호이스팅의 대상이고, 함수 표현식은 호이스팅되지 않는다.
  - 함수 선언문으로 정의한 함수와 함수 표현식으로 정의한 함수의 생성 시점이 다르기 때문이다.

```javascript
// 함수 참조
console.dir(add); // f add(x, y)
console.log(sub); // undefined

// 함수 호출
console.log(add(2, 5)); // 7
console.log(sub(2, 5)); // TypeError: sub is not a function

// 함수 선언문
function add(x, y) {
  return x + y;
}

// 함수 표현식
var sub = function(x, y) {
  return x - y;
}
```

- 함수 선언문은 런타임 이전에 자바스크립트 엔진에 먼저 실행되어 함수 이름과 동일한 이름의 식별자를 암묵적으로 생성하고 생성된 함수 객체를 할당한다.
  - 이로 인해 함수 선언문은 코드의 선두로 끌어 올려진 것처럼 동작하는 호이스팅에 영향을 받는다.

<br>

#### :pushpin: `var` 키워드를 사용한 변수 선언문과 함수 선언문의 호이스팅 차이

- 공통점
  - 런타임 이전에 자바스크립트 엔진에 의해 먼저 실행되어 식별자를 생성한다.
- 차이점
  - 변수 선언문은 `undefined`로 초기화되지만 함수 선언문은 암묵적으로 생성된 식별자는 함수 객체로 초기화되어 함수 선언문 이전에 호출하면 함수 호이스팅에 의해 호출이 가능하다.

<br>

#### :pushpin: 함수 표현식 자체는 호이스팅 대상이 아니다.

- 함수 표현식은 변수에 할당되는 값이 함수 리터럴인 문이다.
  - 따라서 변수 선언문과 변수 할당문을 한 번에 기술한 축약 표현과 동일하게 동작한다.
  - 변수 선언은 런타임 이전에 실행되어 `undefined`로 초기화되지만 <b>변수 할당문의 값은 할당문이 실행되는 시점, 즉 런타임에 평가되므로 함수 표현식의 함수 리터럴도 할당문이 실행되는 시점에 평가되어 함수 객체가 된다.</b>
- 따라서 함수 표현식으로 함수를 정의하면 엄밀히 말해서 <b>함수 호이스팅이 발생하는 것이 아니라 변수 호이스팅이 발생한다.</b>

![function03](https://user-images.githubusercontent.com/52685250/154846504-fbee9dd3-35ac-4675-8cdb-ca46723c3a26.JPG)

- 함수 표현식 이전에 함수를 참조하면 `undefined`로 평가된다.
  - 따라서 이때 함수를 호출하면 `undefined`를 호출하는 것과 마찬가지이므로 타입 에러가 발생한다.
  - 따라서 함수 표현식으로 정의한 함수는 반드시 <b>함수 표현식 이후에 참조 또는 호출</b>해야 한다.

<br>

### (4) `Function` 생성자 함수

- `Function` 생성자 함수에 매개변수 목록과 함수 몸체를 문자열로 전달하면서 `new` 연산자와 함께 호출하면 함수 객체를 생성해서 반환한다.

```javascript
var add = new Function('x', 'y', 'return x + y');

console.log(add(2, 5)); // 7
```

- `Function` 생성자 함수로 함수를 생성하는 방식은 일반적이지 않으며 바람직하지도 않다.
  - 지금까지 살펴본 함수 생성 방식과 다르게 동작하는 부분이 다소 존재한다.

<br>

### (5) 화살표 함수 (arrow function)

- ES2015에서 도입된 화살표 함수는 `function` 키워드 대신 화살표(`=>`)를 사용해 좀더 간략한 방법으로 함수를 선언할 수 있다.
- 화살표 함수는 항상 익명 함수로 정의한다.

```javascript
const add = (x, y) => x + y;
console.log(add(2, 5)); // 7
```

- 화살표 함수는 기존의 함수 선언문 또는 함수 표현식을 완전히 대체한 것이 아니다.
  - 기존의 함수보다 표현만 간략한 것이 아니라 내부 동작 또한 간략화되어 있다.
- 그리고 기존 함수와 달리 `this` 바인딩도 다르고, `prototype` 프로퍼티가 없으며 `arguments` 객체를 생성하지 않는 등 다른 특징들을 가지고 있는데 화살표 함수에 대한 내용은 추후 'Chapter26'에서 자세히 살펴보도록 하자.

<br>

## 5. 함수 호출

(작성중...)
